function out = interp1cubicL(x, M, y)
% Interpolates M(x) onto the grid y using cubic lagrange interpolation

x_N = length(x);
% Check about strict monotonicity of x and x_N>2 ?
% Check M same length as x?
% Check all y lie in the range of x?

% Set up the pointwise polynomial matrix!
pp_mat = zeros((x_N-1),4);
% These may all be upside down.
% Linear in first and last interval
pp_mat(1,:) = [0,0,(M(2)-M(1))/(x(2)-x(1)),M(1)];
pp_mat(x_N-1,:) = [0;0;(M(end)-M(end-1))/(x(2)-x(1));M(end-1)];
for ii=2:(x_N-2)
    xtilde = [x((ii-1):(ii+2))] - x(ii);
    m_scale = [...
        (xtilde(1)-xtilde(2))*(xtilde(1)-xtilde(3))*(xtilde(1)-xtilde(4));...
        (xtilde(2)-xtilde(1))*(xtilde(2)-xtilde(3))*(xtilde(2)-xtilde(4));...
        (xtilde(3)-xtilde(1))*(xtilde(3)-xtilde(2))*(xtilde(3)-xtilde(4));...
        (xtilde(4)-xtilde(1))*(xtilde(4)-xtilde(2))*(xtilde(4)-xtilde(3));...
        ];
    mtilde = [M((ii-1):(ii+2))];
    mtilde = mtilde(:)./m_scale;
    A = [1, 1, 1, 1;...
        -(xtilde(2)+xtilde(3)+xtilde(4)), -(xtilde(1)+xtilde(3)+xtilde(4)),...
        -(xtilde(1)+xtilde(2)+xtilde(4)), -(xtilde(1)+xtilde(2)+xtilde(3));...
        xtilde(2)*xtilde(3)+xtilde(2)*xtilde(4)+xtilde(3)*xtilde(4),...
        xtilde(1)*xtilde(3)+xtilde(1)*xtilde(4)+xtilde(3)*xtilde(4),...
        xtilde(1)*xtilde(2)+xtilde(1)*xtilde(4)+xtilde(2)*xtilde(4),...
        xtilde(1)*xtilde(2)+xtilde(1)*xtilde(3)+xtilde(2)*xtilde(3);...
        -xtilde(2)*xtilde(3)*xtilde(4), -xtilde(1)*xtilde(3)*xtilde(4),...
        -xtilde(1)*xtilde(2)*xtilde(4), -xtilde(1)*xtilde(2)*xtilde(3)];
    pp_mat(ii,:) = (A*mtilde(:))';

end % for loop
% pp format
if nargin==2
    out= mkpp(x,pp_mat);
elseif nargin==3
    out = ppval(mkpp(x,pp_mat),y);
end % function
